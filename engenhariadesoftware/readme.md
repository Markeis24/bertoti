# üìö Meu Reposit√≥rio de Atividades

Este reposit√≥rio cont√©m 8 atividades realizadas como parte dos meus estudos em Engenharia de Software. Cada atividade est√° organizada em sua pr√≥pria pasta, com c√≥digo, diagramas ou documentos relacionados.

---

## üìå Atividades

### 1Ô∏è‚É£ Atividade 1:

**Descri√ß√£o:** 

Comentar com suas palavras o primeiro trecho do livro Software Engineering at Google, Oreilly.  

**Resposta:**  

- O livro come√ßa destacando que existe uma diferen√ßa clara entre simplesmente programar e realmente fazer engenharia de software. Programar √© focado em escrever c√≥digo, enquanto engenharia de software envolve planejamento, teoria, colabora√ß√£o e boas pr√°ticas para construir sistemas que funcionam de forma confi√°vel e que possam evoluir ao longo do tempo.

Ele tamb√©m ressalta que o software √© intang√≠vel ‚Äî n√£o √© algo f√≠sico como uma ponte ou um motor ‚Äî e exatamente por isso exige ainda mais cuidado na sua constru√ß√£o. Por n√£o podermos ver ou tocar o software, seus problemas e impactos nem sempre s√£o √≥bvios, mas podem afetar milh√µes de pessoas. Por isso, assim como nas engenharias tradicionais, √© necess√°rio seguir processos, organizar o trabalho e pensar na manuten√ß√£o futura para que o software seja seguro, escal√°vel e duradouro.

---

### 2Ô∏è‚É£ Atividade 2: 

**Descri√ß√£o:**

Comentar com suas palavras o segundo trecho do livro Software Engineering at Google, Oreilly.

**Resposta:**  

- No segundo trecho, o livro refor√ßa que engenharia de software n√£o √© apenas produzir c√≥digo, mas principalmente pensar no software ao longo do tempo. Isso significa considerar que todo sistema vai precisar ser corrigido, ampliado, reescrito ou adaptado conforme a empresa cresce e as necessidades mudam.

O autor explica que programar resolve o problema de hoje, mas a engenharia de software precisa garantir que o sistema continue funcionando amanh√£, daqui a meses e at√© anos. Como o software √© intang√≠vel, ele pode parecer simples por fora, mas internamente acumula complexidade conforme novas funcionalidades s√£o adicionadas ‚Äî e √© a√≠ que o trabalho de engenharia se torna fundamental.

Nesse contexto, o livro apresenta tr√™s ideias principais que guiam todo o restante da obra:

***1. Tempo e mudan√ßa:***
Todo software muda continuamente. Por isso, √© preciso escrever e organizar c√≥digo pensando em futura manuten√ß√£o, legibilidade e adapta√ß√£o. A mudan√ßa √© inevit√°vel, ent√£o o sistema deve ser constru√≠do para suport√°-la.

***2. Escala e crescimento:***
√Ä medida que produtos e equipes crescem, problemas simples se tornam complexos. O livro discute como lidar com grande volume de usu√°rios, dados, servi√ßos e tamb√©m como coordenar muitos desenvolvedores trabalhando juntos sem gerar caos.

***3. Trade-offs e custos:***
Cada decis√£o t√©cnica tem um custo ‚Äî seja de complexidade, desempenho, manuten√ß√£o ou tempo de trabalho. Engenheiros precisam equilibrar essas escolhas, entendendo que n√£o existe solu√ß√£o perfeita, mas sim a mais adequada para o longo prazo.

Assim, o foco do trecho √© mostrar que engenharia de software √© sobre sustentabilidade, organiza√ß√£o e decis√µes inteligentes, sempre pensando no futuro do sistema e n√£o apenas na sua constru√ß√£o inicial.

---

### 3Ô∏è‚É£ Atividade 3: 

**Descri√ß√£o:**  

Listar e explicar 3 exemplos de tradeoffs  

**Resposta:**  

***- Simplicidade vs. Flexibilidade***

Simplicidade: um c√≥digo simples √© f√°cil de entender, manter e testar. Menos partes significa menos chances de erro.

Flexibilidade: um c√≥digo flex√≠vel aceita mais varia√ß√µes, adapta-se a novos requisitos e permite extens√µes futuras.

Trade-off: quanto mais flex√≠vel voc√™ tenta tornar um sistema, mais complexidade acaba adicionando (abstra√ß√µes, interfaces, configura√ß√µes etc.). Por outro lado, se voc√™ busca simplicidade m√°xima, o sistema fica r√≠gido e dif√≠cil de adaptar no futuro.
Exemplo: criar uma fun√ß√£o muito simples, mas que atende apenas um caso espec√≠fico, versus criar uma fun√ß√£o mais gen√©rica que trata v√°rios cen√°rios, por√©m se torna mais dif√≠cil de entender.

***- Velocidade de entrega vs. Qualidade do software***

Velocidade: entregar r√°pido pode ser crucial para lan√ßamentos, prazos e competi√ß√£o de mercado.

Qualidade: exige testes, revis√£o, documenta√ß√£o e cuidado com arquitetura.

Trade-off: quando a equipe prioriza velocidade, a qualidade costuma cair (bugs, c√≥digo apressado, pouca documenta√ß√£o). Quando prioriza qualidade, a entrega leva mais tempo.
Exemplo: fazer um ‚Äúprot√≥tipo‚Äù r√°pido para atender uma urg√™ncia do cliente vs. investir mais dias corrigindo detalhes, testando e estruturalmente melhorando o c√≥digo.

***- Performance vs. Legibilidade do c√≥digo***

Performance: otimiza√ß√µes deixam o software mais r√°pido, consumindo menos mem√≥ria ou processando mais dados.

Legibilidade: c√≥digo limpo, organizado e f√°cil de entender facilita manuten√ß√£o e evita erros.

Trade-off: otimiza√ß√µes profundas geralmente deixam o c√≥digo mais complicado, menos leg√≠vel ou mais dif√≠cil de manter. J√° um c√≥digo muito leg√≠vel pode sacrificar desempenho em partes cr√≠ticas.
Exemplo: usar estruturas de dados altamente otimizadas por√©m complexas, versus usar estruturas simples que qualquer desenvolvedor entende, mas que n√£o entregam o mesmo desempenho.

---

### 4Ô∏è‚É£ Atividade 4: 

**Descri√ß√£o:**  

 Cria√ß√£o de um diagrama de classes em UML para o desenvolvimento das atividades seguintes.

**Arquivos:**

- Diagrama: [Cl√≠nica Veterin√°ria UML](Atividade_4/ClinicaVeterinaria.pdf)  

---

### 5Ô∏è‚É£ Atividade 5:

**Descri√ß√£o:**  

Desenvolvimento do c√≥digo a partir do diagrama de classes na atividade 4 utilizando a classe teste.  

**Arquivos:**  

- C√≥digo: [Atividade 5](Atividade_5/Clinica_Veterinaria/src)  
- Documento: [Imagens](Atividade_5/ImagemCodigo_5)  

---

### 6Ô∏è‚É£ Atividade 6: 
**Descri√ß√£o:**  
Desenvolvimento de um novo c√≥digo usando o mesmo diagrama.  

**Arquivos:**  
- C√≥digo: [Atividade 6](Atividade_6/Clinica_Veterinaria_Buscar/src)  
- Documento: [Imagens](Atividade_6/ImagemCodigo_6) 

---

### 7Ô∏è‚É£ Atividade 7: 
**Descri√ß√£o:**  
C√≥digo feito nas atividades anteriores com a adi√ß√£o do SQLite.  

**Arquivos:**  
- C√≥digo: [Atividade 7](Atividade_7/Biblioteca)  
- Documento: [Imagens](Atividade_7/Imagem_Codigo_Atividade7)   

---

### 8Ô∏è‚É£ Atividade 8:
**Descri√ß√£o:**  
Integra√ß√£o do Ollama4j no c√≥digo da atividade.  

**Arquivos:**  
- C√≥digo: [Atividade 8](Atividade_8/Ollama)
- Documento: [Imagens](Atividade_8/Ollama)    

---

### üöÄ Tecnologias Utilizadas

- ‚òï **Java 25** 
    
-  üß© **AstahUML** ‚Äì Modelagem UML  

-  üí° **IntelliJ IDEA** ‚Äì Desenvolvimento do c√≥digo  

-  üóÑÔ∏è **SQLite** ‚Äì Banco de dados  

-  ü§ñ **Ollama4j** ‚Äì Integra√ß√£o com IA local  

-  üß≠ **GitHub** ‚Äì Versionamento e publica√ß√£o 

---

### üë©‚Äçüíª Autor

Atividades desenvolvidas por Giovanna Marques Rodrigues, estudante da FATEC S√£o Jos√© dos Campos.
